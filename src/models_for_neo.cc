#include <regex.h>
#include <limits>
#include <mutex>
#include "proto/neo_model.pb.h"
#include "proto/config.pb.h"
#include "util/common.h"
#include "util/threadpool.h"
#include "util/file.h"
#include "util/split.h"
#include "data/common.h"

DEFINE_double(alpha, 0.05, "alpha");
DEFINE_double(beta, 1, "beta");
DEFINE_double(lambda1, 1, "L1-regulization");
DEFINE_double(lambda2, 0, "L2-regulization");
DEFINE_double(coefficient_n, 1,
  "Coefficient for second-order gradient");

DEFINE_string(input_model_files, "./ctr_S*.model.neo_model_features",
  "Required model_features proto files "
  "which are generated by PS_CDN Servers. "
  "Regex supported. "
  "Example: /data01/tiger/Asada/ctr_S*.model.neo_model_features");
DEFINE_string(input_ip_port_file, "",
  "A plain-text file contains all ip:port combinations. "
  "One ip:port each line, which corresponds to a parameter server instance");
DEFINE_string(output_dir, "./",
  "Directory contains all output data");
DEFINE_string(show, "", "The detailed path of model file I want to peek");
DEFINE_string(remote_dir, "",
  "The remote directory which I will copy output model to");

PS::string getHostName() {
  const size_t kBufLen = 1024;
  char buf[kBufLen + 1];

  PS::string ret;
  if (0 == gethostname(buf, kBufLen)) {
    buf[kBufLen - 1] = '\0';
    ret = buf;
  }
  return ret;
}

// List all qualified files with regex under a specific directory
std::vector<PS::string> matchFiles(const PS::string& input_model_files) {
  std::vector<PS::string> ret;
  regex_t reg;
  const size_t kNMatch = 4;
  regmatch_t pmatch[kNMatch];
  const size_t kErrBufLen = 1024;
  char err_buf[kErrBufLen + 1];

  int reg_errno = regcomp(&reg, PS::getFilename(input_model_files).c_str(), 0);
  if (0 != reg_errno) {
    regerror(reg_errno, &reg, err_buf, kErrBufLen);
    std::cerr << "matchFiles try to compile regrex [" <<
      PS::getFilename(input_model_files) << "] but failed. [" <<
      err_buf << "]" << std::endl;
    return ret;
  }

  std::vector<PS::string> files_in_dir =
    PS::readFilenamesInDirectory(PS::getPath(input_model_files));

  for (auto& f : files_in_dir) {
    PS::string file_name = PS::getFilename(f);
    if (!file_name.empty() && file_name.back() == '\n') {
      file_name.resize(file_name.size() - 1);
    }

    // Compare
    reg_errno = regexec(&reg, file_name.c_str(), kNMatch, pmatch, 0);
    if (0 == reg_errno) {
      ret.push_back(PS::getPath(input_model_files) + "/" + file_name);
    } else if (REG_NOMATCH != reg_errno) {
      regerror(reg_errno, &reg, err_buf, kErrBufLen);
      std::cerr << "matchFiles try to match regrex [" <<
        PS::getFilename(input_model_files) << "] to candidate [" <<
        file_name << "] but failed. [" <<
        err_buf << "]" << std::endl;
    }
  }

  regfree(&reg);
  return ret;
}

// print readable NEO model
void showNeoModel(const PS::string& path) {
  std::ifstream in(path);
  if (!in) {
    std::cerr << __PRETTY_FUNCTION__ << " cannot open [" << path << "]" << std::endl;
    return;
  }

  // buffer
  const size_t kBufLen = 1024 * 1024 * 16; // 16MB
  std::unique_ptr<char[]> buf_ptr(new char[kBufLen + 1]);

  try {
    std::stringstream ss;

    // meta
    size_t segment_size = 0;
    if (!in.read(reinterpret_cast<char*>(&segment_size), sizeof(segment_size))) {
      throw std::runtime_error("read meta size failed");
    }
    if (0 == segment_size || segment_size > kBufLen ||
        !in.read(buf_ptr.get(), segment_size)) {
      ss << "read meta body failed; meta_size: " << segment_size;
      throw std::runtime_error(ss.str());
    }

    neo::proto::ModelMeta meta;
    if (!meta.ParseFromArray(buf_ptr.get(), segment_size)) {
      throw std::runtime_error("parse meta failed");
    }
    std::cerr << "NEO model_size: " << meta.model_size() << std::endl;

    // segments
    while (true) {
      if (!in.read(reinterpret_cast<char*>(&segment_size), sizeof(segment_size))) {
        break;
      }
      if (0 == segment_size || segment_size > kBufLen ||
          !in.read(buf_ptr.get(), segment_size)) {
        ss << "read segment body failed; segment_size: " << segment_size;
        throw std::runtime_error(ss.str());
      }

      neo::proto::ModelFeatures features;
      if (!features.ParseFromArray(buf_ptr.get(), segment_size)) {
        throw std::runtime_error("parse segment failed");
      }

      CHECK_EQ(features.fid_size(), features.n_size());
      CHECK_EQ(features.fid_size(), features.z_size());
      CHECK_EQ(features.fid_size(), features.value_size());
      for (size_t i = 0; i < features.fid_size() /*&& i < 32*/; ++i) {
        std::cerr << "fid: " << features.fid(i) <<
          "; n: " << features.n(i) <<
          "; z: " << features.z(i) <<
          "; w: " << features.value(i) << std::endl;
      }
    };
  } catch (std::exception& e) {
    std::cerr << __PRETTY_FUNCTION__ << " " << e.what() <<
      " [" << path << "]" << std::endl;
  }
}

class NeoModel {
  public:
    NeoModel(const PS::string& ip, const PS::string& port):
      ip_(ip),
      port_(port),
      model_size_(0) {
      std::stringstream ss;
      ss << "mkdir -p " << FLAGS_output_dir;
      CHECK_EQ(system(ss.str().c_str()), 0) <<
        "Cannot execute shell cmd [" << ss.str() << "]";

      PS::string hostname = getHostName();
      CHECK(!ss.str().empty()) << "getHostName failed";

      ss.str("");
      ss << FLAGS_output_dir << "/" << hostname << ".cdn_model." << ip_ << "." << port;
      final_out_stream_.open(ss.str(), std::ofstream::out | std::ofstream::trunc);
      CHECK(final_out_stream_) <<
        "Open [" << ss.str() << "] for write failed";
      final_out_path_ = ss.str();

      ss << ".stash";
      stash_out_stream_.open(ss.str(), std::ofstream::out | std::ofstream::trunc);
      CHECK(stash_out_stream_) <<
        "Open [" << ss.str() << "] for write failed";
      stash_path_ = ss.str();
    }
    NeoModel(const NeoModel& other) = delete;
    NeoModel& operator= (const NeoModel& rhs) = delete;

    ~NeoModel() {
      // Dump remaining stash_
      if (stash_.fid_size() > 0) {
        dumpStash();
      }
      stash_out_stream_.close();
      CHECK(stash_out_stream_) << "Close stash_out_stream_ failed";

      // Open stash file for read
      std::ifstream in_body(stash_path_);
      CHECK(in_body) << "Open stash file [" << stash_path_ << "] for read failed";

      // Put head
      neo::proto::ModelMeta head;
      head.set_model_size(model_size_);
      PS::string serialized;
      CHECK(head.SerializeToString(&serialized)) <<
        "head.SerializeToString failed";
      const size_t size = serialized.size();
      CHECK(final_out_stream_.write(reinterpret_cast<const char*>(&size),
                                    sizeof(size))) <<
        "Dump head size failed";
      CHECK(final_out_stream_.write(serialized.data(), size)) <<
        "Dump head proto failed";

      // Concatenate
      final_out_stream_ << in_body.rdbuf();

      // Close and Remove stash file
      in_body.close();
      CHECK_EQ(system((PS::string("unlink ") + stash_path_).c_str()), 0) <<
        "Remove stash file failed [" << stash_path_ << "]";

      // Close and transfer final output file
      final_out_stream_.close();
      CHECK(final_out_stream_) << "Close final output failed";

      if (!FLAGS_remote_dir.empty()) {
        std::stringstream ss;
        ss << "scp -o \"StrictHostKeyChecking no\" " <<
          final_out_path_ << " tiger@" << ip_ <<
          ":" << FLAGS_remote_dir << "/";
        CHECK_EQ(0, system(ss.str().c_str())) << "Transfer failed [" <<
          ss.str() << "]" << std::endl;
      }
    }

    // Add one FeatureID.
    void addFeature(
      uint64 fid,
      float weight,
      float second_order_gradient) {
      second_order_gradient *= FLAGS_coefficient_n;
      float z = getZ(second_order_gradient, weight);

      stash_.add_fid(fid);
      stash_.add_value(weight);
      stash_.add_n(second_order_gradient);
      stash_.add_z(z);
      model_size_++;

      if (model_size_ > 0 && 0 == model_size_ % 40000) {
        dumpStash();
      }
    }

  private:
    void dumpStash() {
      PS::string serialized;
      CHECK(stash_.SerializeToString(&serialized)) <<
        "stash_.SerializeToString failed";

      const size_t size = serialized.size();
      CHECK_LT(size, 1024 * 1024) << "block size must be less than 1MB";

      CHECK(stash_out_stream_.write(reinterpret_cast<const char*>(&size),
                                    sizeof(size))) <<
        "Dump block size to stash failed";
      CHECK(stash_out_stream_.write(serialized.data(), size)) <<
        "Dump block body to stash failed";

      stash_.Clear();
    }

    float getZ(const float second_order_gradient, const float weight) {
      if (0 == weight) {
        // If the current FeatureID is disabled by L1-regulization in PS_CDN,
        //   NEO should consider it as disabled at the very beginning.
        // Another choice: make n a rather large value,
        //   so that NEO could not revive this FeatureID for ever.
        return 0;
      }

      float eta =
        (FLAGS_beta + sqrt(second_order_gradient)) / FLAGS_alpha + FLAGS_lambda2;
      eta = 1 / eta;

      if (weight > 0) {
        return weight / (0 - eta) - FLAGS_lambda1;
      } else {
        return weight / (0 - eta) + FLAGS_lambda1;
      }
    }

  private:
    const PS::string ip_;
    const PS::string port_;

    std::ofstream stash_out_stream_;
    std::ofstream final_out_stream_;

    neo::proto::ModelFeatures stash_;
    PS::string stash_path_;
    PS::string final_out_path_;

    // How many FeatureIDs resides in the NeoModel
    size_t model_size_;
};

int main(int argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);
  // Log out instantly
  FLAGS_logbuflevel = -1;

  if (!FLAGS_show.empty()) {
    showNeoModel(FLAGS_show);
    return 0;
  }

  // List all source model_features proto files
  auto input_files = matchFiles(FLAGS_input_model_files);
  CHECK_GT(input_files.size(), 0) <<
    "[" << FLAGS_input_model_files << "] contains no file";

  // Open ip:port file
  CHECK(!FLAGS_input_ip_port_file.empty()) <<
    "FLAGS_input_ip_port_file must not be empty";
  std::ifstream in_ip_port(FLAGS_input_ip_port_file);
  CHECK(in_ip_port) << "Open in_ip_port [" << FLAGS_input_ip_port_file << "] failed";

  // Parse ip:port file
  std::vector<std::shared_ptr<NeoModel>> neo_model_ptrs;
  PS::string line;
  while (std::getline(in_ip_port, line)) {
    if (!line.empty() && '\n' == line.back()) {
      line.resize(line.size() - 1);
    }

    auto vec = PS::split(line, ':');
    CHECK_EQ(2, vec.size()) <<
      "ip:port file [" << FLAGS_input_ip_port_file << "] contains illegal line [" <<
      line << "]";

    neo_model_ptrs.push_back(std::shared_ptr<NeoModel>(new NeoModel(vec[0], vec[1])));
  }
  CHECK_GT(neo_model_ptrs.size(), 0) << "Found not any ip:port in [" <<
    FLAGS_input_ip_port_file << "]";

  // Traverse all input ModelFeatures proto files
  for (const auto& in_path : input_files) {
    // Open proto file
    std::ifstream in(in_path);
    CHECK(in) <<
      "Open input ModelFeatures proto file failed [" << in_path << "]";

    // Parse from file
    neo::proto::ModelFeatures in_model;
    CHECK(in_model.ParseFromIstream(&in)) <<
      "Parse input ModelFeatures proto file failed [" << in_path << "]";
    CHECK_EQ(in_model.fid_size(), in_model.value_size()) <<
      "fid size and value size is not consistent in [" << in_path << "]";
    CHECK_EQ(in_model.fid_size(), in_model.n_size()) <<
      "fid size and n size is not consistent in [" << in_path << "]";

    // Add to NeoModels
    for (size_t i = 0; i < in_model.fid_size(); ++i) {
      const uint64 fid = in_model.fid(i);
      auto ptr = neo_model_ptrs.at(fid % neo_model_ptrs.size());
      ptr->addFeature(fid, in_model.value(i), in_model.n(i));
    }
  }

  return 0;
}
