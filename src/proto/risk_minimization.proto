package PS;
import "proto/range.proto";
import "proto/evaluation.proto";

message BlockSolverConfig {
  // the number of example in a block. It is the minibatch size for
  // minibatch-sgd. If <= 0, then use the whole data
  optional int64 minibatch_size = 1 [default = 0];

  // divide a feature group into feature_block_ratio x nnz_feature_per_instance
  // blocks. If = 0, then use all features
  optional float feature_block_ratio = 2 [default = 0];

  // use a random order to updating feature block, it improves the
  // convergence. You may turn it off for debug use
  optional bool random_feature_block_order = 3 [default = true];

  optional int32 max_pass_of_data = 8 [default = 10];

  // bounded-delay consistency
  optional int32 max_block_delay = 10 [default = 0];

  // convergance critiria. stop if the relative objective <= epsilon
  optional double epsilon = 11 [default = 1e-4];

  // precision of auc, the larger the better
  optional int64 auc_goodness = 12 [default = 100000];
}


message BCDL1LRConfig {
  optional double delta_init_value = 1 [default = 1];
  optional double delta_max_value = 2 [default = 5];
  // optional bool KKT_filter = 1 [default = true];

  // kkt_filter_threshold = max_gradient_violation / num_examples *
  // kkt_filter_threshold_ratio. increasing this number reduces the effect of
  // kkt filter.
  optional double kkt_filter_threshold_ratio = 10 [default = 10];

}

message LossConfig {
  enum Type {
    SQUARE = 1;
    LOGIT = 2;
    HINGE = 3;
    SQUARE_HINGE = 4;
  }
  required Type type = 1;
}

message LearnerConfig {
  enum Type {
    GRADIENT_DESCENT = 1;
    PROXIMAL_GRADIENT = 2;
    LBFGS = 3;
  }
  required Type type = 1;
}

// message PenaltyConfig {
//   enum Type {
//     L1 = 1;
//     L2 = 2;
//   }
//   required Type type = 1;
//   required float coefficient = 2 [default = 0];
// }


message RiskMinProgress {
  optional double objv = 1;
  optional double relative_objv = 2;
  optional uint64 nnz_w = 5;
  optional double violation = 6;
  optional uint64 nnz_active_set = 7;
  optional double training_auc = 8;
  optional AUCData training_auc_data = 9;

  // performance
  optional double total_time = 10;
  repeated double busy_time = 11;
}

message RiskMinCall {
  enum Command {
    PREPARE_DATA = 1;
    UPDATE_MODEL = 2;
    EVALUATE_PROGRESS = 3;
    SAVE_MODEL = 4;  // save w
    SAVE_AS_DENSE = 7;     // save X * w in a given key range
    RECOVER = 5;
    COMPUTE_VALIDATION_AUC = 6;
    LOAD_DATA = 8;
  }
  required Command cmd = 1;
  optional PbRange key = 2;
  optional int32 feature_group_id = 3;

  optional double kkt_filter_threshold = 4;
  optional bool kkt_filter_reset = 5;

  repeated PbRange reduce_range = 6;
  optional string name = 7;
}

message AggGradLearnerArg {
  optional double learning_rate = 1;
}
